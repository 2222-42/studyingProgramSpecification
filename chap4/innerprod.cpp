//
// THIS FILE IS AUTOMATICALLY GENERATED!!
//
// Generated at 2020-08-28 by the VDM-SL to C++ Code Generator
// (v9.0.7 - Sat 09-Jun-2018 09:35:14 +0900)
//
// This file was genereted from "E:/VDM-SL/studyingProgramSpecification/chap4/innerprod.vdmsl".


#include "innerprod.h"


#ifdef DEF_innerprod_USERIMPL

#include "innerprod_userimpl.cpp"


#endif // DEF_innerprod_USERIMPL


void init_innerprod () {}

#ifndef DEF_innerprod_IntSeqSum

Int vdm_innerprod_IntSeqSum (const type_iL &vdm_innerprod_s) {
  return ((vdm_innerprod_s == Sequence()) ? Int(0) : static_cast<Int>(vdm_innerprod_s.Hd()) + vdm_innerprod_IntSeqSum(vdm_innerprod_s.Tl()));
}

#endif // DEF_innerprod_IntSeqSum

#ifndef DEF_innerprod_innerprod

Int vdm_innerprod_innerprod (const type_iL &vdm_innerprod_a, const type_iL &vdm_innerprod_b) {
  if (!vdm_innerprod_pre_innerprod(vdm_innerprod_a, vdm_innerprod_b).GetValue()) {
    CGUTIL::RunTime(L"Precondition failure in innerprod");
  }
  Sequence tmpSeq_5;
  for (int count_6 = 1; count_6 <= vdm_innerprod_a.Length(); count_6++) {
    Int vdm_innerprod_i (count_6);
    if (vdm_innerprod_b.OutOfRange(vdm_innerprod_i.GetValue())) {
      CGUTIL::RunTime(L"Illegal index");
    }
    tmpSeq_5.ImpAppend(static_cast<Int>(vdm_innerprod_a[vdm_innerprod_i]) * static_cast<Int>(vdm_innerprod_b[vdm_innerprod_i]));
  }
  return vdm_innerprod_IntSeqSum(tmpSeq_5);
}

#endif // DEF_innerprod_innerprod

#ifndef DEF_innerprod_pre_innerprod

Bool vdm_innerprod_pre_innerprod (const type_iL &vdm_innerprod_a, const type_iL &vdm_innerprod_b) {
  return Bool(vdm_innerprod_a.Length() == vdm_innerprod_b.Length());
}

#endif // DEF_innerprod_pre_innerprod


