//
// THIS FILE IS AUTOMATICALLY GENERATED!!
//
// Generated at 2020-08-28 by the VDM-SL to C++ Code Generator
// (v9.0.7 - Sat 09-Jun-2018 09:35:14 +0900)
//
// This file was genereted from "E:/VDM-SL/studyingProgramSpecification/chap4/maximumOp.vdmsl".


#include "maximumOp.h"


static Int vdm_maximumOp_N;

static Sequence vdm_maximumOp_x;

TYPE_maximumOp_valseq &TYPE_maximumOp_valseq::Init (const Int &p1, const type_iL &p2) {
  this->SetField(1, p1);
  this->SetField(2, p2);
  return * this;
}

Int TYPE_maximumOp_valseq::get_N () const {
  return this->GetInt(1);
}

void TYPE_maximumOp_valseq::set_N (const Int &p) {
  this->SetField(1, p);
}

type_iL TYPE_maximumOp_valseq::get_x () const {
  return this->GetSequence(2);
}

void TYPE_maximumOp_valseq::set_x (const type_iL &p) {
  this->SetField(2, p);
}

void init_maximumOp_VDMLib () {
  VDMGetDefaultRecInfoMap().NewTag(TAG_TYPE_maximumOp_valseq, 2);
  VDMGetDefaultRecInfoMap().SetSymTag(TAG_TYPE_maximumOp_valseq, L"maximumOp`valseq");
  AddRecordTag(L"maximumOp`valseq", TAG_TYPE_maximumOp_valseq);
}

#include "maximumOp_userimpl.cpp"


void init_maximumOp () {
  init_maximumOp_VDMLib();
}

#ifndef DEF_maximumOp_pre_maximumOp

Bool vdm_maximumOp_pre_maximumOp (const TYPE_maximumOp_valseq &var_1_1) {
  const Int vdm_maximumOp_N (var_1_1.GetInt(pos_maximumOp_valseq_N));
  const Sequence vdm_maximumOp_x (var_1_1.GetSequence(pos_maximumOp_valseq_x));
  return Bool(vdm_maximumOp_N.GetValue() == vdm_maximumOp_x.Length());
}

#endif // DEF_maximumOp_pre_maximumOp

#ifndef DEF_maximumOp_post_maximumOp

Bool vdm_maximumOp_post_maximumOp (const Int &var_1_1, const TYPE_maximumOp_valseq &var_2_2, const TYPE_maximumOp_valseq &var_3_3) {
  const Int vdm_maximumOp_m (var_1_1);
  const Int _vdm_maximumOp_N (var_2_2.GetInt(pos_maximumOp_valseq_N));
  const Sequence _vdm_maximumOp_x (var_2_2.GetSequence(pos_maximumOp_valseq_x));
  const Int vdm_maximumOp_N (var_3_3.GetInt(pos_maximumOp_valseq_N));
  const Sequence vdm_maximumOp_x (var_3_3.GetSequence(pos_maximumOp_valseq_x));
  Bool varRes_4;
  if (vdm_maximumOp_x.Inds().InSet(vdm_maximumOp_m)) {
    bool tmpQuant_10 = true;
    const Set e1_set_13 (vdm_maximumOp_x.Inds());
    Set tmpSet_23 (e1_set_13);
    Generic tmpe_22;
    for (bool bb_21 = tmpSet_23.First(tmpe_22); bb_21 && tmpQuant_10; bb_21 = tmpSet_23.Next(tmpe_22)) {
      const Int vdm_maximumOp_j (tmpe_22);
      if (vdm_maximumOp_x.OutOfRange(vdm_maximumOp_m.GetValue())) {
        CGUTIL::RunTime(L"Illegal index");
      }
      if (!((static_cast<Int>(vdm_maximumOp_x[vdm_maximumOp_m])).GetValue() >= (static_cast<Int>(vdm_maximumOp_x[vdm_maximumOp_j])).GetValue())) {
        tmpQuant_10 = false;
      }
    }
    varRes_4 = Bool(tmpQuant_10);
  }
  else {
    varRes_4 = Bool(false);
  }
  return varRes_4;
}

#endif // DEF_maximumOp_post_maximumOp


