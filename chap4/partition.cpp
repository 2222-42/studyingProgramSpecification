//
// THIS FILE IS AUTOMATICALLY GENERATED!!
//
// Generated at 2020-08-28 by the VDM-SL to C++ Code Generator
// (v9.0.7 - Sat 09-Jun-2018 09:35:14 +0900)
//
// This file was genereted from "E:/VDM-SL/studyingProgramSpecification/chap4/partition.vdmsl".


#include "partition.h"


static Int vdm_partition_N;

static Sequence vdm_partition_x;

TYPE_partition_array &TYPE_partition_array::Init (const Int &p1, const type_iL &p2) {
  this->SetField(1, p1);
  this->SetField(2, p2);
  return * this;
}

Int TYPE_partition_array::get_N () const {
  return this->GetInt(1);
}

void TYPE_partition_array::set_N (const Int &p) {
  this->SetField(1, p);
}

type_iL TYPE_partition_array::get_x () const {
  return this->GetSequence(2);
}

void TYPE_partition_array::set_x (const type_iL &p) {
  this->SetField(2, p);
}

void init_partition_VDMLib () {
  VDMGetDefaultRecInfoMap().NewTag(TAG_TYPE_partition_array, 2);
  VDMGetDefaultRecInfoMap().SetSymTag(TAG_TYPE_partition_array, L"partition`array");
  AddRecordTag(L"partition`array", TAG_TYPE_partition_array);
}

#include "partition_userimpl.cpp"


void init_partition () {
  init_partition_VDMLib();
}

#ifndef DEF_partition_numberof

Int vdm_partition_numberof (const Int &vdm_partition_n, const type_iL &vdm_partition_s) {
  Set res_s_5;
  const Set e1_set_9 (vdm_partition_s.Inds());
  Set tmpSet_17 (e1_set_9);
  Generic tmpe_16;
  for (bool bb_15 = tmpSet_17.First(tmpe_16); bb_15; bb_15 = tmpSet_17.Next(tmpe_16)) {
    const Int vdm_partition_i (tmpe_16);
    if ((static_cast<Int>(vdm_partition_s[vdm_partition_i])).GetValue() == vdm_partition_n.GetValue()) {
      res_s_5.Insert(vdm_partition_i);
    }
  }
  return Int(res_s_5.Card());
}

#endif // DEF_partition_numberof

#ifndef DEF_partition_partitioned

Bool vdm_partition_partitioned (const type_iL &vdm_partition_x, const Int &vdm_partition_c) {
  bool tmpQuant_4 = true;
  const Set e1_set_7 (vdm_partition_x.Inds());
  Set tmpSet_28 (e1_set_7);
  Generic tmpe_27;
  for (bool bb_26 = tmpSet_28.First(tmpe_27); bb_26 && tmpQuant_4; bb_26 = tmpSet_28.Next(tmpe_27)) {
    const Int vdm_partition_j (tmpe_27);
    Set tmpSet_25 (e1_set_7);
    Generic tmpe_24;
    for (bool bb_23 = tmpSet_25.First(tmpe_24); bb_23 && tmpQuant_4; bb_23 = tmpSet_25.Next(tmpe_24)) {
      const Int vdm_partition_i (tmpe_24);
      if (!((((static_cast<Int>(vdm_partition_x[vdm_partition_i])).GetValue() < vdm_partition_c.GetValue()) ? (vdm_partition_c.GetValue() < (static_cast<Int>(vdm_partition_x[vdm_partition_j])).GetValue()) : false) ? (vdm_partition_i.GetValue() < vdm_partition_j.GetValue()) : true)) {
        tmpQuant_4 = false;
      }
    }
  }
  return Bool(tmpQuant_4);
}

#endif // DEF_partition_partitioned

#ifndef DEF_partition_permutation

Bool vdm_partition_permutation (const type_iL &vdm_partition_a, const type_iL &vdm_partition_b) {
  Bool varRes_3;
  if (vdm_partition_a.Length() == vdm_partition_b.Length()) {
    bool tmpQuant_10 = true;
    const Set e1_set_13 (vdm_partition_a.Elems());
    Set tmpSet_23 (e1_set_13);
    Generic tmpe_22;
    for (bool bb_21 = tmpSet_23.First(tmpe_22); bb_21 && tmpQuant_10; bb_21 = tmpSet_23.Next(tmpe_22)) {
      const Int vdm_partition_n (tmpe_22);
      if (!(vdm_partition_numberof(vdm_partition_n, vdm_partition_a).GetValue() == vdm_partition_numberof(vdm_partition_n, vdm_partition_b).GetValue())) {
        tmpQuant_10 = false;
      }
    }
    varRes_3 = Bool(tmpQuant_10);
  }
  else {
    varRes_3 = Bool(false);
  }
  return varRes_3;
}

#endif // DEF_partition_permutation

#ifndef DEF_partition_pre_partition

Bool vdm_partition_pre_partition (const TYPE_partition_array &var_1_1) {
  const Int vdm_partition_N (var_1_1.GetInt(pos_partition_array_N));
  const Sequence vdm_partition_x (var_1_1.GetSequence(pos_partition_array_x));
  return Bool(vdm_partition_N.GetValue() == vdm_partition_x.Length());
}

#endif // DEF_partition_pre_partition

#ifndef DEF_partition_post_partition

Bool vdm_partition_post_partition (const TYPE_partition_array &var_1_1, const TYPE_partition_array &var_2_2) {
  const Int _vdm_partition_N (var_1_1.GetInt(pos_partition_array_N));
  const Sequence _vdm_partition_x (var_1_1.GetSequence(pos_partition_array_x));
  const Int vdm_partition_N (var_2_2.GetInt(pos_partition_array_N));
  const Sequence vdm_partition_x (var_2_2.GetSequence(pos_partition_array_x));
  if (_vdm_partition_x.OutOfRange((vdm_partition_N + Int(Int(1) / Int(2))).GetValue())) {
    CGUTIL::RunTime(L"Illegal index");
  }
  return Bool(vdm_partition_partitioned(vdm_partition_x, _vdm_partition_x[vdm_partition_N + Int(Int(1) / Int(2))]).GetValue() ? vdm_partition_permutation(vdm_partition_x, _vdm_partition_x).GetValue() : false);
}

#endif // DEF_partition_post_partition


