--
-- Module: Address
--
-- Description: 
--
-- Version: 
-- Author: 
--

module Address

--imports
--  from ModuleA all,
--  from ModuleB all

exports all

definitions

--state Sigma of
--  a : nat
--  b : nat
--  inv mk_Sigma(x,y) == x >= y
--  init s == s = mk_Sigma(0,0)
--end

types
    Name = String;
    Address = String;
    AddressBook = map Name to Address;

    String = seq of char;

    Report = <ok> | <error>

values

operations

functions
    AddAddress: Name * Address * AddressBook -> AddressBook
    AddAddress(name, address, book) ==
        book munion {name |-> address}
    pre name not in set dom(book);

    EAddAddress: Name * Address * AddressBook -> AddressBook
    EAddAddress(name, address, book) ==
        book
    pre name in set dom(book);

    RAddAddress: Name * Address * AddressBook -> AddressBook * Report
    RAddAddress(name, address, book) ==
        if name not in set dom(book)
        then mk_(book munion {name |-> address}, <ok>)
        else mk_(book, <error>);
    
    RAddAddressAlt: Name * Address * AddressBook -> AddressBook * Report
    RAddAddressAlt(name, address, book) ==
        if pre_AddAddress(name, address, book)
        then mk_(AddAddress(name, address, book), <ok>)
        else mk_(EAddAddress(name, address, book), <error>);

    FindAddress: Name * AddressBook -> Address
    FindAddress(name, book) ==
        book(name)
    pre name in set dom(book);

    EFindAddress: Name * AddressBook -> [Address]
    EFindAddress(name, book) ==
        nil
    pre name not in set dom(book);

    RFindAddress: Name * AddressBook -> [Address] * Report
    RFindAddress(name, book) ==
        if pre_FindAddress(name, book)
        then mk_(FindAddress(name, book), <ok>)
        else mk_(EFindAddress(name, book), <error>)

end Address
